#include "gtest/gtest.h"
#include "midi_time.h"
#include "mtrk_event_t.h"
#include "mtrk_event_methods.h"
#include <vector>
#include <cstdint>


//
// Tests of the copy ctor and copy assignment operator.  
//
// Events are "small" (in the SBO-sense) meta events from the midi std and
// from files observed in the wild.  All are initially constructed passing 
// 0 for the value of the running-status.  
//
TEST(mtrk_event_t_tests, metaEventsSmallCopyCtorAndCopyAssign) {
	std::vector<std::vector<unsigned char>> tests {
		//
		// From p.142 of the midi std
		//
		{{0x00,0xFF,0x58,0x04,0x04,0x02,0x18,0x08}},  // Time sig
		{{0x00,0xFF,0x51,0x03,0x07,0xA1,0x20}},  // Tempo
		{{0x00,0xFF,0x2F,0x00}},  // End of track
		//
		// Not from the midi std
		//
		{{0x00,0xFF,0x51,0x03,0x07,0xA1,0x20}},  // Tempo (CLEMENTI.MID)
		// Padded w/ zeros, but otherwise identical to above:
		{{0x00,0xFF,0x51,0x03,0x07,0xA1,0x20,0x00,0x00,0x00,0x00}},
		{{0x00,0xFF,0x01,0x10,0x48,0x61,0x72,0x70,0x73,0x69,0x63,0x68,
			0x6F,0x72,0x64,0x20,0x48,0x69,0x67,0x68}}   // Text element "Harpsichord High"
	};

	for (const auto& e : tests) {
		auto maybe_ev = jmid::make_mtrk_event(e.data(),e.data()+e.size(),0,
			nullptr,e.size());
		EXPECT_TRUE(maybe_ev);
		auto c1 = maybe_ev.event;
		
		//---------------------------------------------------------------------------
		// copy ctor:
		const auto c2 = c1;

		EXPECT_EQ(c2.status_byte(),c1.status_byte());
		EXPECT_EQ(c2.delta_time(),c1.delta_time());
		EXPECT_EQ(c2.size(),c1.size());
		EXPECT_EQ(c2.data_size(),c1.data_size());
		for (int i=0; i<c2.size(); ++i) {
			EXPECT_EQ(c2[i],e[i]);
			EXPECT_EQ(*(c2.data()+i),e[i]);
		}

		//---------------------------------------------------------------------------
		// copy assign:
		maybe_ev = jmid::make_mtrk_event(tests[0].data(),
			tests[0].data()+tests[0].size(),0,nullptr,tests[0].size());
		auto c3 = maybe_ev.event;
		c3 = c1;

		EXPECT_EQ(c3.status_byte(),c1.status_byte());
		EXPECT_EQ(c3.delta_time(),c1.delta_time());

		EXPECT_EQ(c3.size(),c1.size());
		EXPECT_EQ(c3.data_size(),c1.data_size());
		for (int i=0; i<c3.size(); ++i) {
			EXPECT_EQ(c3[i],e[i]);
		}
	}
}


//
// Tests of the copy ctor and copy assignment operator invoked between
// big events.  
//
TEST(mtrk_event_t_tests, metaEventsBigCopyCtorAndCopyAssign) {
	std::vector<std::vector<unsigned char>> tests {
		{0x00,0xFF,0x03,0x1D,  // 0x1D==29; Sequence/track name (Hallelujah.mid)
		0x48,0x61,0x6C,0x6C,0x65,0x6C,0x75,0x6A,
		0x61,0x68,0x21,0x20,0x4A,0x6F,0x79,0x20,0x74,0x6F,0x20,0x74,
		0x68,0x65,0x20,0x57,0x6F,0x72,0x6C,0x64,0x21},  

		{0x00,0xFF,0x01,0x7F,  // Text event; 127 (0x7F) chars
		0x6D,0x6F,0x75,0x6E,0x74,0x20,0x6F,0x66,0x20,0x74,0x65,0x78,
		0x74,0x20,0x64,0x65,0x73,0x63,0x72,0x69,0x62,0x69,0x6E,0x67,
		0x20,0x61,0x6E,0x79,0x74,0x68,0x69,0x6E,0x67,0x2E,0x20,0x49,
		0x74,0x20,0x69,0x73,0x20,0x61,0x20,0x67,0x6F,0x6F,0x64,0x20,
		0x69,0x64,0x65,0x61,0x20,0x74,0x6F,0x20,0x70,0x75,0x74,0x20,
		0x61,0x20,0x74,0x65,0x78,0x74,0x20,0x65,0x76,0x65,0x6E,0x74,
		0x20,0x72,0x69,0x67,0x68,0x74,0x20,0x61,0x74,0x20,0x74,0x68,
		0x65,0x0D,0x0A,0x62,0x65,0x67,0x69,0x6E,0x6E,0x69,0x6E,0x67,
		0x20,0x6F,0x66,0x20,0x61,0x20,0x74,0x72,0x61,0x63,0x6B,0x2C,
		0x20,0x77,0x69,0x74,0x68,0x20,0x74,0x68,0x65,0x20,0x6E,0x61,
		0x6D,0x65,0x20,0x6F,0x66,0x20,0x74},  

		{0x00,0xFF,0x01,0x5F,  // Text event; 95 (0x5F) chars
		0x6D,0x6F,0x75,0x6E,0x74,0x20,0x6F,0x66,0x20,0x74,0x65,0x78,
		0x74,0x20,0x64,0x65,0x73,0x63,0x72,0x69,0x62,0x69,0x6E,0x67,
		0x20,0x61,0x6E,0x79,0x74,0x68,0x69,0x6E,0x67,0x2E,0x20,0x49,
		0x74,0x20,0x69,0x73,0x20,0x61,0x20,0x67,0x6F,0x6F,0x64,0x20,
		0x69,0x64,0x65,0x61,0x20,0x74,0x6F,0x20,0x70,0x75,0x74,0x20,
		0x61,0x20,0x74,0x65,0x78,0x74,0x20,0x65,0x76,0x65,0x6E,0x74,
		0x20,0x72,0x69,0x67,0x68,0x74,0x20,0x61,0x74,0x20,0x74,0x68,
		0x6D,0x65,0x20,0x6F,0x66,0x20,0x74,0x74,0x74,0x74,0x74}  
	};
	
	bool first_iter=true;
	for (const auto& e : tests) {
		auto maybe_ev = jmid::make_mtrk_event(e.data(),e.data()+e.size(),0,
			nullptr,e.size());
		EXPECT_TRUE(maybe_ev);
		auto c1 = maybe_ev.event;

		//---------------------------------------------------------------------------
		// copy ctor:
		auto c2 = c1;
		EXPECT_EQ(c2.status_byte(),c1.status_byte());
		EXPECT_EQ(c2.delta_time(),c1.delta_time());

		EXPECT_EQ(c2.size(),c1.size());
		EXPECT_EQ(c2.data_size(),c1.data_size());
		for (int i=0; i<e.size(); ++i) {
			EXPECT_EQ(c2[i],e[i]);
		}

		//---------------------------------------------------------------------------
		// copy assign:
		// c1 is created from tests[i]; create a c3 different from c1
		// then overwrite it with c1.  
		int j=1;
		if (!first_iter) {
			j=0;
		}
		maybe_ev = jmid::make_mtrk_event(tests[j].data(),
			tests[j].data()+tests[j].size(),0,nullptr,tests[j].size());
		auto c3 = maybe_ev.event;
		c3 = c1;
		EXPECT_EQ(c3.status_byte(),c1.status_byte());
		EXPECT_EQ(c3.delta_time(),c1.delta_time());

		EXPECT_EQ(c3.size(),c1.size());
		EXPECT_EQ(c3.data_size(),c1.data_size());
		for (int i=0; i<e.size(); ++i) {
			EXPECT_EQ(c3[i],e[i]);
		}

		first_iter=false;
	}
}


// 
// Test the move asssign operator by move-assigning a big event into
// a small event.  Meta events are random events generated by dbk 05/08/19.  
//
TEST(mtrk_event_t_tests, metaEventsMoveAssignBigIntoSmall) {
	struct test_t {
		std::vector<unsigned char> bytes {};
		uint32_t dtval {0};
		uint8_t type_byte;
		uint8_t payload_len;
		uint32_t data_size {0};
	};
	test_t small_data {
		{0x89,0x58,0xFF,0x58,0x04,0xDB,0x81,0x7A,0x0B},
		1240,0x58u,4,7
	};
	test_t big_data {
		{0x8B,0xD3,0x8E,0x62,0xFF,0x05,0x81,0x2C,0x4C,0x6F,0x72,0x65,0x6D,0x20,0x69,
			0x70,0x73,0x75,0x6D,0x20,0x73,0x6F,0x64,0x61,0x6C,0x65,0x73,0x20,0x6E,
			0x75,0x6E,0x63,0x20,0x76,0x75,0x6C,0x70,0x75,0x74,0x61,0x74,0x65,0x20,
			0x61,0x63,0x63,0x75,0x6D,0x73,0x61,0x6E,0x20,0x20,0x20,0x20,0x20,0x20,
			0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
			0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x6D,0x61,0x65,0x63,
			0x65,0x6E,0x61,0x73,0x20,0x76,0x69,0x74,0x61,0x65,0x2C,0x20,0x65,0x6C,
			0x69,0x74,0x20,0x65,0x6C,0x65,0x69,0x66,0x65,0x6E,0x64,0x20,0x63,0x6F,
			0x6E,0x76,0x61,0x6C,0x6C,0x69,0x73,0x20,0x6E,0x65,0x71,0x75,0x65,0x20,
			0x66,0x61,0x6D,0x65,0x73,0x20,0x64,0x69,0x61,0x6D,0x20,0x63,0x6F,0x6E,
			0x73,0x65,0x71,0x75,0x61,0x74,0x2C,0x70,0x6F,0x72,0x74,0x61,0x20,0x63,
			0x75,0x72,0x61,0x65,0x20,0x67,0x72,0x61,0x76,0x69,0x64,0x61,0x20,0x6C,
			0x65,0x6F,0x20,0x66,0x61,0x75,0x63,0x69,0x62,0x75,0x73},
		24430434,0x05u,172,176
	};

	auto maybe_small = jmid::make_mtrk_event(small_data.bytes.data(),
		small_data.bytes.data()+small_data.bytes.size(),0,nullptr,
		small_data.bytes.size());
	EXPECT_TRUE(maybe_small);
	auto small = maybe_small.event;
	EXPECT_EQ(small.delta_time(),small_data.dtval);
	EXPECT_TRUE(jmid::is_meta(small));
	EXPECT_EQ(small.size(),small_data.bytes.size());
	EXPECT_EQ(small.data_size(),small_data.data_size);

	auto maybe_big = jmid::make_mtrk_event(big_data.bytes.data(),
		big_data.bytes.data()+big_data.bytes.size(),0,nullptr,
		big_data.bytes.size());
	EXPECT_TRUE(maybe_big);
	auto big = maybe_big.event;
	EXPECT_EQ(big.delta_time(),big_data.dtval);
	EXPECT_TRUE(jmid::is_meta(big));
	EXPECT_EQ(big.size(),big_data.bytes.size());
	EXPECT_EQ(big.data_size(),big_data.data_size);
	
	//-------------------------------------------------------------------------
	// Force use of move assign w/ std::move()
	auto small_mvinto = small;
	auto big_mvfrom = big;
	small_mvinto=std::move(big_mvfrom);
	// 'big' now has the moved-from state of an array of 0x00u's; the first 
	// 0x00u is interpreted as a delta_time == 0; the event is otherwise
	// invalid
	EXPECT_EQ(big_mvfrom.delta_time(),0);
	EXPECT_TRUE(jmid::is_channel(big_mvfrom));
	EXPECT_EQ(big_mvfrom.size(),4);
	EXPECT_EQ(big_mvfrom.data_size(),3);
	// small has the values as if constructed from big_data
	EXPECT_EQ(small_mvinto.delta_time(),big_data.dtval);
	EXPECT_TRUE(jmid::is_meta(small_mvinto));
	EXPECT_EQ(small_mvinto.size(),big_data.bytes.size());
	EXPECT_EQ(small_mvinto.data_size(),big_data.data_size);

	//-------------------------------------------------------------------------
	// Invoke move-assign by assigning from a temporary
	small_mvinto = small;
	small_mvinto = jmid::make_mtrk_event(big_data.bytes.data(),
		big_data.bytes.data()+big_data.bytes.size(),0,nullptr,
		big_data.bytes.size()).event;
	// small has the values as if constructed from big_data
	EXPECT_EQ(small_mvinto.delta_time(),big_data.dtval);
	EXPECT_TRUE(jmid::is_meta(small_mvinto));
	EXPECT_EQ(small_mvinto.size(),big_data.bytes.size());
	EXPECT_EQ(small_mvinto.data_size(),big_data.data_size);
}


// 
// Test of the move asssign operator by move-assigning a small event into
// a big event.  Meta events are random events generated by dbk 05/08/19.  
//
TEST(mtrk_event_t_tests, metaEventsMoveAssignSmallIntoBig) {
	struct test_t {
		std::vector<unsigned char> bytes {};
		uint32_t dtval {0};
		uint8_t type_byte;
		uint8_t payload_len;
		uint32_t data_size {0};
	};
	test_t small_data {
		{0x89,0x58,0xFF,0x58,0x04,0xDB,0x81,0x7A,0x0B},
		1240,0x58u,4,7
	};
	test_t big_data {
		{0x8B,0xD3,0x8E,0x62,0xFF,0x05,0x81,0x2C,0x4C,0x6F,0x72,0x65,0x6D,0x20,0x69,
			0x70,0x73,0x75,0x6D,0x20,0x73,0x6F,0x64,0x61,0x6C,0x65,0x73,0x20,0x6E,
			0x75,0x6E,0x63,0x20,0x76,0x75,0x6C,0x70,0x75,0x74,0x61,0x74,0x65,0x20,
			0x61,0x63,0x63,0x75,0x6D,0x73,0x61,0x6E,0x20,0x20,0x20,0x20,0x20,0x20,
			0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
			0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x6D,0x61,0x65,0x63,
			0x65,0x6E,0x61,0x73,0x20,0x76,0x69,0x74,0x61,0x65,0x2C,0x20,0x65,0x6C,
			0x69,0x74,0x20,0x65,0x6C,0x65,0x69,0x66,0x65,0x6E,0x64,0x20,0x63,0x6F,
			0x6E,0x76,0x61,0x6C,0x6C,0x69,0x73,0x20,0x6E,0x65,0x71,0x75,0x65,0x20,
			0x66,0x61,0x6D,0x65,0x73,0x20,0x64,0x69,0x61,0x6D,0x20,0x63,0x6F,0x6E,
			0x73,0x65,0x71,0x75,0x61,0x74,0x2C,0x70,0x6F,0x72,0x74,0x61,0x20,0x63,
			0x75,0x72,0x61,0x65,0x20,0x67,0x72,0x61,0x76,0x69,0x64,0x61,0x20,0x6C,
			0x65,0x6F,0x20,0x66,0x61,0x75,0x63,0x69,0x62,0x75,0x73},
		24430434,0x05u,172,176
	};

	auto maybe_small = jmid::make_mtrk_event(small_data.bytes.data(),
		small_data.bytes.data()+small_data.bytes.size(),0,nullptr,
		small_data.bytes.size());
	EXPECT_TRUE(maybe_small);
	auto small = maybe_small.event;

	EXPECT_EQ(small.delta_time(),small_data.dtval);
	EXPECT_TRUE(jmid::is_meta(small));
	EXPECT_EQ(small.size(),small_data.bytes.size());
	EXPECT_EQ(small.data_size(),small_data.data_size);

	auto maybe_big = jmid::make_mtrk_event(big_data.bytes.data(),
		big_data.bytes.data()+big_data.bytes.size(),0,nullptr,
		big_data.bytes.size());
	EXPECT_TRUE(maybe_big);
	auto big = maybe_big.event;
	EXPECT_EQ(big.delta_time(),big_data.dtval);
	EXPECT_TRUE(jmid::is_meta(big));
	EXPECT_EQ(big.size(),big_data.bytes.size());
	EXPECT_EQ(big.data_size(),big_data.data_size);
	
	//-------------------------------------------------------------------------
	// Force use of move assign w/ std::move()
	auto big_mvinto = big;
	auto small_mvfrom = small;
	big_mvinto=std::move(small_mvfrom);
	// small_mvfrom now has the moved-from state
	EXPECT_EQ(small_mvfrom.delta_time(),0);

	EXPECT_TRUE(jmid::is_channel(small_mvfrom));
	EXPECT_EQ(small_mvfrom.size(),4);
	EXPECT_EQ(small_mvfrom.data_size(),3);
	// big_mvinto (which is no longer "big") has the values as if 
	// constructed from small_data
	EXPECT_EQ(big_mvinto.delta_time(),small_data.dtval);
	EXPECT_TRUE(jmid::is_meta(big_mvinto));
	EXPECT_EQ(big_mvinto.size(),small_data.bytes.size());
	EXPECT_EQ(big_mvinto.data_size(),small_data.data_size);

	//-------------------------------------------------------------------------
	// Invoke move-assign by assigning from a temporary
	big_mvinto = big;
	big_mvinto = jmid::make_mtrk_event(small_data.bytes.data(),
		small_data.bytes.data()+small_data.bytes.size(),0,nullptr,
		small_data.bytes.size()).event;
	// big_mvinto (which is no longer "big") has the values as if 
	// constructed from small_data
	EXPECT_EQ(big_mvinto.delta_time(),small_data.dtval);
	EXPECT_TRUE(jmid::is_meta(big_mvinto));
	EXPECT_EQ(big_mvinto.size(),small_data.bytes.size());
	EXPECT_EQ(big_mvinto.data_size(),small_data.data_size);
}


// 
// Which meta events have a text field?
//
TEST(mtrk_event_t_tests, metaEventTypeHasText) {
	struct test_t {
		jmid::meta_event_t t {jmid::meta_event_t::unknown};
		bool ans_hastext {false};
	};
	std::vector<test_t> tests {
		{jmid::meta_event_t::seqn,false},
		{jmid::meta_event_t::text,true},
		{jmid::meta_event_t::copyright,true},
		{jmid::meta_event_t::trackname,true},
		{jmid::meta_event_t::instname,true},
		{jmid::meta_event_t::lyric,true},
		{jmid::meta_event_t::marker,true},
		{jmid::meta_event_t::cuepoint,true},
		{jmid::meta_event_t::chprefix,false},
		{jmid::meta_event_t::eot,false},
		{jmid::meta_event_t::tempo,false},
		{jmid::meta_event_t::smpteoffset,false},
		{jmid::meta_event_t::timesig,false},
		{jmid::meta_event_t::keysig,false},
		{jmid::meta_event_t::seqspecific,false},
		{jmid::meta_event_t::invalid,false},
		{jmid::meta_event_t::unknown,false}
	};

	for (const auto& e : tests) {
		EXPECT_EQ(jmid::meta_hastext_impl(static_cast<uint16_t>(e.t)),e.ans_hastext);
	}

}


